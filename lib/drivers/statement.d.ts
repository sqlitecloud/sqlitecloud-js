/**
 * statement.ts
 */
import { Database } from './database';
import { RowCallback, RowsCallback, RowCountCallback, ResultsCallback } from './types';
/**
 * A statement generated by Database.prepare used to prepare SQL with ? bindings.
 *
 * SCSP protocol does not support named placeholders yet.
 */
export declare class Statement<T> {
    constructor(database: Database, sql: string, ...params: any[]);
    /** Statement belongs to this database */
    private _database;
    /** The SQL statement with ? binding placeholders */
    private _sql;
    /** The SQL statement with binding values applied */
    private _preparedSql;
    /**
     * Binds parameters to the prepared statement and calls the callback when done
     * or when an error occurs. The function returns the Statement object to allow
     * for function chaining. The first and only argument to the callback is null
     * when binding was successful. Binding parameters with this function completely
     * resets the statement object and row cursor and removes all previously bound
     * parameters, if any.
     *
     * In SQLiteCloud the statement is prepared on the database server and binding errors
     * are raised on execution time.
     */
    bind(...params: any[]): this;
    /**
     * Binds parameters and executes the statement. The function returns the Statement object to
     * allow for function chaining. If you specify bind parameters, they will be bound to the statement
     * before it is executed. Note that the bindings and the row cursor are reset when you specify
     * even a single bind parameter. The callback behavior is identical to the Database#run method
     * with the difference that the statement will not be finalized after it is run. This means you
     * can run it multiple times.
     */
    run(callback?: ResultsCallback<T>): this;
    run(params: any, callback?: ResultsCallback<T>): this;
    /**
     * Binds parameters, executes the statement and retrieves the first result row.
     * The function returns the Statement object to allow for function chaining.
     * The parameters are the same as the Statement#run function, with the following differences:
     * The signature of the callback is function(err, row) {}. If the result set is empty,
     * the second parameter is undefined, otherwise it is an object containing the values
     *  for the first row.
     */
    get(callback?: RowCallback<T>): this;
    get(params: any, callback?: RowCallback<T>): this;
    /**
     * Binds parameters, executes the statement and calls the callback with
     * all result rows. The function returns the Statement object to allow
     * for function chaining. The parameters are the same as the Statement#run function
     */
    all(callback?: RowsCallback<T>): this;
    all(params: any, callback?: RowsCallback<T>): this;
    /**
     * Binds parameters, executes the statement and calls the callback for each result row.
     * The function returns the Statement object to allow for function chaining. Parameters
     * are the same as the Database#each function.
     */
    each(callback?: RowCallback<T>, complete?: RowCountCallback): this;
    each(params: any, callback?: RowCallback<T>, complete?: RowCountCallback): this;
}
