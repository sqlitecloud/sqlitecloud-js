/**
 * statement.ts
 */

import { popCallback } from './utilities'
import { Database } from './database'
import { ErrorCallback, RowCallback, RowsCallback, RowCountCallback, ResultsCallback, SQLiteCloudCommand } from './types'

/* eslint-disable @typescript-eslint/explicit-module-boundary-types */

/**
 * A statement generated by Database.prepare used to prepare SQL with ? bindings.
 *
 * SCSP protocol does not support named placeholders yet.
 */
export class Statement<T> {
  constructor(database: Database, sql: string, ...params: any[]) {
    this._database = database
    this._sql = sql
    this.bind(...params)
  }

  /** Statement belongs to this database */
  private _database: Database

  /** The SQL statement with ? binding placeholders */
  private _sql: string

  /** The SQL statement with binding values applied */
  private _preparedSql: SQLiteCloudCommand = { query: '' }

  /**
   * Binds parameters to the prepared statement and calls the callback when done
   * or when an error occurs. The function returns the Statement object to allow
   * for function chaining. The first and only argument to the callback is null
   * when binding was successful. Binding parameters with this function completely 
   * resets the statement object and row cursor and removes all previously bound 
   * parameters, if any.
   * 
   * In SQLiteCloud the statement is prepared on the database server and binding errors
   * are raised on execution time.
   */
  public bind(...params: any[]): this {
    const { args, callback } = popCallback<ErrorCallback>(params)
    this._preparedSql = { query: this._sql, parameters: args }
    if (callback) {
      callback.call(this, null)
    }
    return this
  }

  /**
   * Binds parameters and executes the statement. The function returns the Statement object to
   * allow for function chaining. If you specify bind parameters, they will be bound to the statement
   * before it is executed. Note that the bindings and the row cursor are reset when you specify
   * even a single bind parameter. The callback behavior is identical to the Database#run method
   * with the difference that the statement will not be finalized after it is run. This means you
   * can run it multiple times.
   */
  public run(callback?: ResultsCallback<T>): this
  public run(params: any, callback?: ResultsCallback<T>): this
  public run(...params: any[]): this {
    const { args, callback } = popCallback<ResultsCallback>(params || [])
    if (args?.length > 0) {
      // apply new bindings then execute
      this.bind(...args, () => {
        this._database.run(this._preparedSql.query || '', this._preparedSql.parameters, callback)
      })
    } else {
      // execute prepared sql with same bindings
      this._database.run(this._preparedSql.query || '', this._preparedSql.parameters, callback)
    }

    return this
  }

  /**
   * Binds parameters, executes the statement and retrieves the first result row.
   * The function returns the Statement object to allow for function chaining.
   * The parameters are the same as the Statement#run function, with the following differences:
   * The signature of the callback is function(err, row) {}. If the result set is empty,
   * the second parameter is undefined, otherwise it is an object containing the values
   *  for the first row.
   */
  public get(callback?: RowCallback<T>): this
  public get(params: any, callback?: RowCallback<T>): this
  public get(...params: any[]): this {
    const { args, callback } = popCallback<RowCallback>(params || [])
    if (args?.length > 0) {
      // apply new bindings then execute
      this.bind(...args, () => {
        this._database.get(this._preparedSql.query || '', this._preparedSql.parameters, callback)
      })
    } else {
      // execute prepared sql with same bindings
      this._database.get(this._preparedSql.query || '', this._preparedSql.parameters, callback)
    }

    return this
  }

  /**
   * Binds parameters, executes the statement and calls the callback with
   * all result rows. The function returns the Statement object to allow
   * for function chaining. The parameters are the same as the Statement#run function
   */
  public all(callback?: RowsCallback<T>): this
  public all(params: any, callback?: RowsCallback<T>): this
  public all(...params: any[]): this {
    const { args, callback } = popCallback<RowsCallback>(params || [])
    if (args?.length > 0) {
      // apply new bindings then execute
      this.bind(...args, () => {
        this._database.all(this._preparedSql.query || '', this._preparedSql.parameters, callback)
      })
    } else {
      // execute prepared sql with same bindings
      this._database.all(this._preparedSql.query || '', this._preparedSql.parameters, callback)
    }

    return this
  }

  /**
   * Binds parameters, executes the statement and calls the callback for each result row.
   * The function returns the Statement object to allow for function chaining. Parameters
   * are the same as the Database#each function.
   */
  public each(callback?: RowCallback<T>, complete?: RowCountCallback): this
  public each(params: any, callback?: RowCallback<T>, complete?: RowCountCallback): this
  public each(...params: any[]): this {
    const { args, callback, complete } = popCallback<RowCallback<T>>(params)
    if (args?.length > 0) {
      // apply new bindings then execute
      this.bind(...args, () => {
        this._database.each(this._preparedSql.query || '', this._preparedSql.parameters, callback, complete as RowCountCallback)
      })
    } else {
      // execute prepared sql with same bindings
      this._database.each(this._preparedSql.query || '', this._preparedSql.parameters, callback, complete as RowCountCallback)
    }

    return this
  }
}
