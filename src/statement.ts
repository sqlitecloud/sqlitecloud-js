/**
 * statement.ts
 */

import { popCallback, prepareSql } from './utilities'
import { Database, ErrorCallback, RowCallback, RowCountCallback, RowsCallback } from './database'

/** A statement generated by Database.prepare used to prepare SQL with ? bindings */
export class Statement {
  constructor(database: Database, sql: string, ...params: any[]) {
    const { args, callback } = popCallback<ErrorCallback>(params)
    this._database = database
    this._sql = sql
    if (args?.length > 0) {
      this.bind(...args, callback)
    } else {
      callback?.call(this, null)
    }
  }

  /** Statement belongs to this database */
  private _database: Database

  /** The SQL statement with ? binding placeholders */
  private _sql: string

  /** The SQL statement with binding values applied */
  private _preparedSql?: string

  /**
   * Binds parameters to the prepared statement and calls the callback when done
   * or when an error occurs. The function returns the Statement object to allow
   * for function chaining. The first and only argument to the callback is null
   * when binding was successful, otherwise it is the error object. Binding parameters
   * with this function completely resets the statement object and row cursor and
   * removes all previously bound parameters, if any. Currently bound parameters
   * are escaped client side and turned into literals before being executed on the server.
   */
  public bind(...params: any[]): this {
    const { args, callback } = popCallback<ErrorCallback>(params)
    try {
      this._preparedSql = prepareSql(this._sql, ...args)
      if (callback) {
        callback.call(this, null)
      }
    } catch (error) {
      this._preparedSql = undefined
      if (callback) {
        callback.call(this, error as Error)
      }
    }
    return this
  }

  /**
   * Binds parameters and executes the statement. The function returns the Statement object to
   * allow for function chaining. If you specify bind parameters, they will be bound to the statement
   * before it is executed. Note that the bindings and the row cursor are reset when you specify
   * even a single bind parameter. The callback behavior is identical to the Database#run method
   * with the difference that the statement will not be finalized after it is run. This means you
   * can run it multiple times.
   */
  public run(...params: any[]): this {
    const { args, callback } = popCallback<RowCallback>(params || [])
    if (args?.length > 0) {
      // apply new bindings then execute
      this.bind(...args, (error: Error) => {
        if (error) {
          callback?.call(this, error)
        } else {
          this._database.run(this._preparedSql || '', callback)
        }
      })
    } else {
      // execute prepared sql with same bindings
      this._database.run(this._preparedSql || '', callback)
    }

    return this
  }

  /**
   * Binds parameters, executes the statement and retrieves the first result row.
   * The function returns the Statement object to allow for function chaining.
   * The parameters are the same as the Statement#run function, with the following differences:
   * The signature of the callback is function(err, row) {}. If the result set is empty,
   * the second parameter is undefined, otherwise it is an object containing the values
   *  for the first row.
   */
  public get(...params: any[]): this {
    const { args, callback } = popCallback<RowCallback>(params || [])
    if (args?.length > 0) {
      // apply new bindings then execute
      this.bind(...args, (error: Error) => {
        if (error) {
          callback?.call(this, error)
        } else {
          this._database.get(this._preparedSql || '', callback)
        }
      })
    } else {
      // execute prepared sql with same bindings
      this._database.get(this._preparedSql || '', callback)
    }

    return this
  }

  /**
   * Binds parameters, executes the statement and calls the callback with
   * all result rows. The function returns the Statement object to allow
   * for function chaining. The parameters are the same as the Statement#run function
   */
  public all(...params: any[]): this {
    const { args, callback } = popCallback<RowsCallback>(params || [])
    if (args?.length > 0) {
      // apply new bindings then execute
      this.bind(...args, (error: Error) => {
        if (error) {
          callback?.call(this, error)
        } else {
          this._database.all(this._preparedSql || '', callback)
        }
      })
    } else {
      // execute prepared sql with same bindings
      this._database.all(this._preparedSql || '', callback)
    }

    return this
  }

  /**
   * Binds parameters, executes the statement and calls the callback for each result row.
   * The function returns the Statement object to allow for function chaining. Parameters
   * are the same as the Database#each function.
   */
  public each(sql: string, ...params: any[]): this {
    const { args, callback, complete } = popCallback<RowCallback>(params)
    if (args?.length > 0) {
      // apply new bindings then execute
      this.bind(...args, (error: Error) => {
        if (error) {
          callback?.call(this, error)
        } else {
          this._database.each(this._preparedSql || '', callback, complete)
        }
      })
    } else {
      // execute prepared sql with same bindings
      this._database.each(this._preparedSql || '', callback, complete)
    }

    return this
  }
}
